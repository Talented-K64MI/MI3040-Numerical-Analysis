# -*- coding: utf-8 -*-
"""main_rungekutta.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rMlD5VRVcWdQnD5rqQVGuNQF_M6ni_oH
"""

from sympy import *
from math import *
import sys


from lib_rungekutta import *

"""# Phương pháp Runge - Kutta hiện giải bài toán Cauchy cho phương trình vi phân thường

## 1. Nhập dữ liệu

Nhập biểu thức $ y' = f(x, y)$. Lưu ý PT phải đặt trong dấu nháy kép
"""

expr = "x"

"""Nhập giá trị ban đầu $x_{0}$ và $y(x_{0})$"""

x_0 = 0
y_0 = 0

"""Nhập khoảng cách giữa 2 điểm liên tiếp $h$"""

h = 0.1

"""Nhập số mốc của lưới điểm $n$ """

n = 150

"""Nhập số nấc của Runge-Kutta. Các giá trị bao gồm 1, 2, 3, 4 hoặc kiểu hệ số của Heun"""

s = 4

"""## 2. Giải PTVP và in ra kết quả
Cấp chính xác:
"""

precision_x   = 3;
precision_y   = 7;
precision_eps = 12;

"""Giải và in kết quả:

"""

s  = s if(s == "heun" or s == "Heun") else int(s); 
uu = rungekutta_oop(expr, x_0, y_0, h, n, s);
g  = (uu.Solve());

if(s == "heun" or s == "Heun"):
#{
    print(f"Phương pháp Runge-Kutta 3 nấc với cấu hình hệ số kiểu Heun hoàn tất với lưới điểm sau, sai số toàn cục O(h^3) = {round(h**3, precision_eps)}:");
#}
else:
#{
    print(f"Phương pháp Runge-Kutta {s} nấc với hoàn tất với lưới điểm sau, sai số toàn cục O(h^{s}) = {round(h**s, precision_eps)}:");
#}
for x in g: print(round(x[0], precision_x), round(x[1], precision_y));

"""Đồ thị:"""

uu.getPlot()

"""## 3. Nghiệm kiểm chứng
Nhập PT nghiệm kiểm chứng hoặc "NONE" nếu không có
"""

sol_expr = "NONE"

if(sol_expr != "NONE"):
#{
    sol = lambdify(symbols("x"), sympify(sol_expr), "math");
    print("So sánh với giá trị đúng của nghiệm:");
    for x in g: print(f"y*({round(x[0], precision_x)}) = {round(x[1], precision_y)}, so sánh với giá trị chuẩn y({round(x[0], precision_x)}) = {round(sol(x[0]), precision_y)}, sai số {round(abs(sol(x[0]) - x[1]), precision_eps)}");
#}